import javax.swing.*;
import java.awt.*;
import java.awt.event.*;
import java.awt.image.BufferedImage;
import java.io.File;
import javax.imageio.ImageIO;

public class PascalTriangleVisualizer extends JPanel {
    private int rows = 10;
    private int[][] triangle;
    private int currentRow = 0;
    private boolean warmPalette = true;
    private int[][] yOffsets; // Para animar caída de números

    public PascalTriangleVisualizer(int rows) {
        this.rows = rows;
        triangle = new int[rows][];
        yOffsets = new int[rows][];

        for (int i = 0; i < rows; i++) {
            triangle[i] = new int[i + 1];
            yOffsets[i] = new int[i + 1];
            for (int j = 0; j <= i; j++) {
                if (j == 0 || j == i) {
                    triangle[i][j] = 1;
                } else {
                    triangle[i][j] = triangle[i - 1][j - 1] + triangle[i - 1][j];
                }
                yOffsets[i][j] = -20; // Empiezan arriba
            }
        }

        // Timer para construir fila por fila
        Timer rowTimer = new Timer(1000, e -> {
            if (currentRow < rows) {
                currentRow++;
                repaint();
            }
        });
        rowTimer.start();

        // Timer para colores dinámicos
        Timer colorTimer = new Timer(1500, e -> {
            warmPalette = !warmPalette;
            repaint();
        });
        colorTimer.start();

        // Timer para animar caída de números
        Timer fallTimer = new Timer(50, e -> {
            for (int i = 0; i < currentRow; i++) {
                for (int j = 0; j <= i; j++) {
                    if (yOffsets[i][j] < 0) {
                        yOffsets[i][j] += 2; // baja poco a poco
                    }
                }
            }
            repaint();
        });
        fallTimer.start();

        // Tooltip dinámico
        setToolTipText("");
        addMouseMotionListener(new MouseMotionAdapter() {
            public void mouseMoved(MouseEvent e) {
                int size = 40;
                int x0 = getWidth() / 2;
                int y0 = 50;

                for (int i = 0; i < currentRow; i++) {
                    for (int j = 0; j <= i; j++) {
                        int x = x0 - i * size / 2 + j * size;
                        int y = y0 + i * size;
                        if (new Rectangle(x - size / 2, y - size / 2, size, size).contains(e.getPoint())) {
                            setToolTipText("C(" + i + "," + j + ") = " + triangle[i][j]);
                            return;
                        }
                    }
                }
                setToolTipText(null);
            }
        });
    }

    @Override
    protected void paintComponent(Graphics g) {
        super.paintComponent(g);
        Graphics2D g2 = (Graphics2D) g;
        g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON);

        int size = 40;
        int x0 = getWidth() / 2;
        int y0 = 50;

        for (int i = 0; i < currentRow; i++) {
            for (int j = 0; j <= i; j++) {
                int value = triangle[i][j];
                int x = x0 - i * size / 2 + j * size;
                int y = y0 + i * size;

                // Fractal Sierpinski: pares en blanco
                if (value % 2 == 0) {
                    g2.setColor(Color.WHITE);
                } else {
                    g2.setColor(getDynamicColor(value));
                }

                g2.fillOval(x - size / 2, y - size / 2, size, size);

                g2.setColor(Color.BLACK);
                g2.drawOval(x - size / 2, y - size / 2, size, size);

                // Texto animado (caída desde arriba)
                g2.drawString(String.valueOf(value), x - 10, y + yOffsets[i][j]);
            }
        }
    }

    private Color getDynamicColor(int value) {
        float norm = (float) value / triangle[rows - 1][rows / 2];
        if (warmPalette) {
            return new Color(Color.HSBtoRGB(0.1f + norm * 0.1f, 1f, 1f));
        } else {
            return new Color(Color.HSBtoRGB(0.6f - norm * 0.2f, 1f, 1f));
        }
    }

    // Exportación personalizada con JFileChooser
    public void exportImage() {
        JFileChooser chooser = new JFileChooser();
        chooser.setDialogTitle("Guardar imagen");
        chooser.setSelectedFile(new File("triangulo_pascal.png"));
        if (chooser.showSaveDialog(this) == JFileChooser.APPROVE_OPTION) {
            try {
                File file = chooser.getSelectedFile();
                String name = file.getName().toLowerCase();
                String format = name.endsWith(".jpg") ? "jpg" : "png";

                BufferedImage img = new BufferedImage(getWidth(), getHeight(), BufferedImage.TYPE_INT_ARGB);
                Graphics2D g2 = img.createGraphics();
                paint(g2);
                g2.dispose();
                ImageIO.write(img, format, file);
                JOptionPane.showMessageDialog(this, "Imagen exportada: " + file.getName());
            } catch (Exception ex) {
                ex.printStackTrace();
            }
        }
    }

    public static void main(String[] args) {
        JFrame frame = new JFrame("Triángulo de Pascal Interactivo");
        PascalTriangleVisualizer panel = new PascalTriangleVisualizer(12);

        JButton exportButton = new JButton("Exportar Imagen");
        exportButton.addActionListener(e -> panel.exportImage());

        frame.add(panel, BorderLayout.CENTER);
        frame.add(exportButton, BorderLayout.SOUTH);
        frame.setSize(800, 600);
        frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);
        frame.setVisible(true);
    }
}
