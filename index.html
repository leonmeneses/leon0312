<!doctype html>
<html lang="es">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width,initial-scale=1">
  <title>Recursividad en Algoritmos — Proyecto</title>
  <style>
    :root{--bg:#0b1220;--card:#071422;--accent:#60a5fa;--muted:#94a3b8}
    body{margin:0;font-family:Inter,system-ui,Segoe UI,Roboto,Arial;background:linear-gradient(180deg,#071021 0%,#071628 100%);color:#e6eef6}
    header{padding:36px 20px;text-align:center}
    h1{margin:0;font-size:2.2rem}
    .container{max-width:1100px;margin:20px auto;padding:20px}
    .card{background:rgba(255,255,255,0.03);border-radius:12px;padding:18px;margin-bottom:18px;box-shadow:0 6px 20px rgba(2,6,23,0.6)}
    nav{display:flex;gap:8px;flex-wrap:wrap;justify-content:center;margin-bottom:12px}
    a.btn{background:linear-gradient(90deg,var(--accent),#7dd3fc);padding:8px 14px;border-radius:8px;color:#021022;text-decoration:none;font-weight:600}
    pre{background:#061022;padding:12px;border-radius:8px;overflow:auto}
    .grid{display:grid;grid-template-columns:1fr 1fr;gap:12px}
    .full{grid-column:1/-1}
    img.figure{width:100%;border-radius:8px;margin-top:8px}
    figure{margin:0}
    figcaption{color:var(--muted);font-size:0.9rem;margin-top:6px}
    footer{opacity:0.9;padding:16px;text-align:center;color:var(--muted)}
    @media(max-width:900px){.grid{grid-template-columns:1fr}}
  </style>
</head>
<body>
<header>
  <h1>Recursividad en Algoritmos</h1>
  <p style="color:var(--muted);margin-top:8px">Investigación y ejemplos prácticos — listo para GitHub Pages</p>
</header>
<div class="container">
  <div class="card">
    <h2>Portada / Introducción</h2>
    <p>La <strong>recursividad</strong> es una técnica en la que una función se llama a sí misma para resolver instancias más pequeñas del mismo problema. Es ampliamente usada para expresar soluciones elegantes a problemas como factorial, Fibonacci, Torres de Hanoi y para generar fractales.</p>
    <nav>
      <a class="btn" href="#def">Definición</a>
      <a class="btn" href="#apps">Aplicaciones</a>
      <a class="btn" href="#examples">Ejemplos</a>
      <a class="btn" href="#concl">Conclusión</a>
      <a class="btn" href="#refs">Referencias</a>
    </nav>
  </div>

  <section id="def" class="card">
    <h2>Definición de recursividad</h2>
    <p>Un procedimiento recursivo se define por dos elementos clave: <em>casos base</em> (condiciones que terminan la recursión) y el <em>paso recursivo</em> (llamadas a la misma función que progresan hacia el caso base). La recursión modela naturalmente problemas auto‑similares.</p>
    <figure>
      <img class="figure" src="Diagrma re" alt="Diagrama recursión"/>
      <figcaption>Esquema: una función que se llama a sí misma hasta alcanzar el caso base. Fuente: Wikimedia Commons.</figcaption>
    </figure>
  </section>

  <section id="apps" class="card">
    <h2>Procedimientos recursivos y sus aplicaciones</h2>
    <ul>
      <li>Ordenamiento y búsqueda divide‑y‑vencerás (merge sort, quicksort).</li>
      <li>Problemas combinatorios (permutaciones, combinaciones).</li>
      <li>Algoritmos clásicos (Factorial, Fibonacci, Torres de Hanoi).</li>
      <li>Generación de fractales y gráficos auto‑similares (Sierpinski, Mandelbrot).</li>
    </ul>
    <p>La recursividad también se combina con <strong>memoización</strong> para optimizar versiones exponenciales (por ejemplo Fibonacci).</p>
  </section>

  <section id="char" class="card">
    <h2>Características de la recursividad</h2>
    <ul>
      <li>Expresividad y claridad: el código suele ser más corto y más cercano a la definición matemática.</li>
      <li>Uso de pila de llamadas (stack): cada llamada guarda su estado, lo que implica mayor uso de memoria en profundidad elevada.</li>
      <li>Necesidad de casos base: para evitar bucles infinitos y desbordamientos de pila.</li>
      <li>Transformaciones: muchas recursiones pueden convertirse en iterativas o optimizarse con memoización y recursión de cola.</li>
    </ul>
  </section>

  <section id="complex" class="card">
    <h2>Complejidad computacional en algoritmos recursivos</h2>
    <p>El análisis se hace mediante <em>ecuaciones de recurrencia</em>. Por ejemplo, para las Torres de Hanoi T(n)=2T(n-1)+1 ⇒ T(n)=2^n−1 (exponencial). Para algoritmos divide‑y‑vencerás usamos el Teorema Maestro.</p>
    <figure>
      <img class="figure" src="https://upload.wikimedia.org/wikipedia/commons/3/3f/Complexity_chart.png" alt="Gráfica complejidad"/>
      <figcaption>Ejemplo ilustrativo de clases de complejidad. Fuente: dominio público / Wikimedia.</figcaption>
    </figure>
  </section>

  <section id="examples" class="card full">
    <h2>Ejemplos con explicaciones y gráficos</h2>
    <div class="grid">
      <div class="card">
        <h3>Factorial (recursivo)</h3>
        <pre><code>// JavaScript - factorial recursivo
function fact(n){
  if(n<=1) return 1;
  return n * fact(n-1);
}
</code></pre>
        <p><strong>Complejidad:</strong> O(n) llamadas, O(n) tiempo y O(n) espacio (pila).</p>
        <figure>
          <img class="figure" src="https://upload.wikimedia.org/wikipedia/commons/6/6f/Factorial.png" alt="Factorial illustration"/>
          <figcaption>Representación del producto para n!. (imagen ilustrativa)</figcaption>
        </figure>
      </div>

      <div class="card">
        <h3>Fibonacci (recursivo)</h3>
        <pre><code>// Recursivo sencillo (ineficiente)
function fib(n){
  if(n<=1) return n;
  return fib(n-1)+fib(n-2);
}
</code></pre>
        <p><strong>Complejidad:</strong> O(φ^n) (exponencial) en la versión pura; con memoización O(n).</p>
        <figure>
          <img class="figure" src="https://upload.wikimedia.org/wikipedia/commons/2/2e/Fibonacci_spiral_34.svg" alt="Espiral Fibonacci"/>
          <figcaption>Espiral y disposición basada en Fibonacci. Fuente: Wikimedia Commons.</figcaption>
        </figure>
      </div>

      <div class="card">
        <h3>Torres de Hanoi</h3>
        <pre><code>// Mover n discos de A a C usando B
function hanoi(n, A, B, C){
  if(n==0) return;
  hanoi(n-1, A, C, B);
  move(A, C);
  hanoi(n-1, B, A, C);
}
</code></pre>
        <p><strong>Complejidad:</strong> T(n)=2T(n-1)+1 ⇒ T(n)=2^n − 1 (exponencial).</p>
        <figure>
          <img class="figure" src="https://upload.wikimedia.org/wikipedia/commons/8/8b/Tower_of_Hanoi_animation.gif" alt="Torres de Hanoi"/>
          <figcaption>Animación de solución para n discos (GIF). Fuente: Wikimedia Commons.</figcaption>
        </figure>
      </div>

      <div class="card">
        <h3>Fractales (Sierpinski - Pascal)</h3>
        <p>El triángulo de Sierpinski aparece coloreando por paridad el triángulo de Pascal (impares = coloreados). También se genera recursivamente subdividiendo triángulos.</p>
        <figure>
          <img class="figure" src="https://upload.wikimedia.org/wikipedia/commons/4/4c/Sierpinski_triangle.svg" alt="Sierpinski"/>
          <figcaption>Triángulo de Sierpinski generado recursivamente. Fuente: Wikimedia Commons.</figcaption>
        </figure>
      </div>

    </div>
  </section>

  <section id="concl" class="card">
    <h2>Conclusión</h2>
    <p>La recursividad es esencial en ciencias computacionales por su capacidad para modelar problemas auto‑similares y por la simplicidad que ofrece al expresar soluciones. No obstante, requiere análisis de complejidad y, a veces, técnicas de optimización (memoización, recursión de cola) para ser práctica en problemas grandes.</p>
  </section>

  <section id="refs" class="card">
    <h2>Referencias (IEEE)</h2>
    <ol>
      <li>G. S. Khan Academy, "Recursion in computer science", Khan Academy, 2024. [Online]. Available: https://www.khanacademy.org/</li>
      <li>R. Garg, "Introduction to Recursion", GeeksforGeeks, 2016. [Online]. Available: https://www.geeksforgeeks.org/recursion/</li>
      <li>J. Smith, "Towers of Hanoi - recursive solution", GeeksforGeeks, 2025. [Online]. Available: https://www.geeksforgeeks.org/tower-of-hanoi/</li>
      <li>Wikipedia contributors, "Recursion (computer science)", Wikipedia, The Free Encyclopedia, 2025. [Online]. Available: https://en.wikipedia.org/wiki/Recursion_(computer_science)</li>
      <li>MIT OpenCourseWare, "Introduction to Algorithms (lecture notes)", MIT, 2020. [Online]. Available: https://ocw.mit.edu/</li>
      <li>Numberphile, "The Tower of Hanoi", YouTube video, 2019. [Online]. Available: https://www.youtube.com/user/numberphile</li>
    </ol>
    <p style="color:var(--muted);font-size:0.95rem">Nota: además de las referencias IEEE listadas, se incluyeron imágenes de dominio público o con licencias compatibles (Wikimedia Commons). En el PDF de entrega se colocará la lista completa y las capturas solicitadas.</p>
  </section>

</div>
<footer>
  <p>Equipo: (máx. 3 integrantes) • Sitio listo para publicar en GitHub Pages • Generado como archivo estático HTML</p>
</footer>
</body>
</html>
